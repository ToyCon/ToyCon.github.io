{"componentChunkName":"component---src-templates-blog-post-js","path":"/098/2023-02-28-practice56/","result":{"data":{"site":{"siteMetadata":{"title":"ToyCon's Blog"}},"markdownRemark":{"id":"0e3cb3c1-9472-591b-96e2-a491afa5b906","excerpt":"암호 해독 https://school.programmers.co.kr/learn/courses/30/lessons/120892 변수 문자열 cipher 정수 code 제한사항 1 ≤ cipher의 길이 ≤ 1,000 1 ≤ code ≤ cipher의 길이 cipher…","html":"<h3>암호 해독</h3>\n<p><a href=\"https://school.programmers.co.kr/learn/courses/30/lessons/120892\">https://school.programmers.co.kr/learn/courses/30/lessons/120892</a></p>\n<h4>변수</h4>\n<p>문자열 cipher<br>\n정수 code</p>\n<h4>제한사항</h4>\n<p>1 ≤ cipher의 길이 ≤ 1,000<br>\n1 ≤ code ≤ cipher의 길이<br>\ncipher는 소문자와 공백으로만 구성<br>\n공백도 하나의 문자로 취급</p>\n<h4>순서</h4>\n<p>메서드를 쓰는 것보다 정직하게 반복문으로 접근하는 편이 알아보기 쉽고 빠르겠다는 생각이 들었다. cipher의 길이가 길지 않기 때문에, for 반복문으로 1회만 반복하는 방식으로 풀었다.</p>\n<ol>\n<li>변수 res를 선언하고 빈 문자열 할당</li>\n<li>인덱스 번호와 글자의 순서를 맞추기 위해 cipher 앞에 공백 1자리 추가</li>\n<li>i &#x3C; cipher.length 조건의 for 반복문 진입</li>\n<li>i % code === 0 이면 res에 cipher[i]를 추가</li>\n<li>res를 반환</li>\n</ol>\n<h4>코드</h4>\n<p>code를 바로 더하는 방식을 생각하지 못했다. 해당 방식으로 실행 순서를 더 줄일 수 있으니 기억해야겠다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">solution</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cipher<span class=\"token punctuation\">,</span> code</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> res <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n    cipher <span class=\"token operator\">=</span> <span class=\"token string\">' '</span> <span class=\"token operator\">+</span> cipher<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> cipher<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">%</span> code <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> res <span class=\"token operator\">+=</span> cipher<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"암호 해독","date":"February 28, 2023","description":null}},"previous":{"fields":{"slug":"/097/2023-02-28-practice55/"},"frontmatter":{"title":"대문자와 소문자"}},"next":{"fields":{"slug":"/100/2023-03-01-practice57/"},"frontmatter":{"title":"369게임"}}},"pageContext":{"id":"0e3cb3c1-9472-591b-96e2-a491afa5b906","previousPostId":"cbf55a6d-b918-5308-a193-987452fb806c","nextPostId":"5afedb71-ccb1-5629-b2d3-3c8c3f17de3d"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}